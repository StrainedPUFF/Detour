{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wesle\\\\OneDrive\\\\Documents\\\\VLCS\\\\myProject\\\\VirtualLCS\\\\frontend\\\\src\\\\AudioChat.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useState } from 'react';\nimport { useSession } from './SessionContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioChat = () => {\n  _s();\n  const {\n    sessionId\n  } = useSession();\n  const audioRef = useRef(null);\n  const socket = useRef(null);\n  const [isMuted, setIsMuted] = useState(false);\n\n  // Utility to convert PCM data to WAV format\n  const createWAV = pcmData => {\n    const sampleRate = 44100; // Example sample rate\n    const numChannels = 1; // Mono audio\n\n    const wavHeader = new Uint8Array(44); // RIFF header size\n    const wavBody = new Float32Array(pcmData);\n\n    // Fill WAV header\n    const dataSize = wavBody.length * 2; // PCM data size (bytes)\n    const totalSize = dataSize + 44;\n    const dataView = new DataView(wavHeader.buffer);\n    dataView.setUint32(0, 0x52494646); // \"RIFF\"\n    dataView.setUint32(4, totalSize - 8, true); // File size - 8\n    dataView.setUint32(8, 0x57415645); // \"WAVE\"\n    dataView.setUint32(12, 0x666d7420); // \"fmt \"\n    dataView.setUint32(16, 16, true); // PCM chunk size\n    dataView.setUint16(20, 1, true); // Audio format (1=PCM)\n    dataView.setUint16(22, numChannels, true); // Number of channels\n    dataView.setUint32(24, sampleRate, true); // Sample rate\n    dataView.setUint32(28, sampleRate * numChannels * 2, true); // Byte rate\n    dataView.setUint16(32, numChannels * 2, true); // Block align\n    dataView.setUint16(34, 16, true); // Bits per sample\n    dataView.setUint32(36, 0x64617461); // \"data\"\n    dataView.setUint32(40, dataSize, true); // PCM data size\n\n    // Combine header and body\n    return new Blob([wavHeader, new Uint16Array(wavBody.map(x => x * 32767))], {\n      type: 'audio/wav'\n    });\n  };\n\n  // Wrap playAudio in useCallback\n  const playAudio = useCallback(pcmData => {\n    try {\n      // Convert the received audio data object to a Float32Array\n      const floatArray = new Float32Array(Object.values(pcmData));\n\n      // Convert PCM to WAV format\n      const wavBlob = createWAV(floatArray);\n      const audioContext = new AudioContext();\n\n      // Ensure the AudioContext is running\n      if (audioContext.state === 'suspended') {\n        audioContext.resume();\n      }\n      const reader = new FileReader();\n      reader.onload = () => {\n        const arrayBuffer = reader.result;\n\n        // Decode and play the WAV data\n        audioContext.decodeAudioData(arrayBuffer).then(decodedData => {\n          const source = audioContext.createBufferSource();\n          source.buffer = decodedData;\n          source.connect(audioContext.destination);\n          source.start();\n        }).catch(error => {\n          console.error(\"Error decoding audio data:\", error);\n        });\n      };\n      reader.readAsArrayBuffer(wavBlob); // Read the WAV Blob as ArrayBuffer\n    } catch (error) {\n      console.error(\"Error playing audio:\", error.message);\n    }\n  }, []); // Add dependencies if needed\n\n  const connectWebSocket = useCallback(() => {\n    if (!sessionId) {\n      console.error('Session ID is undefined. Unable to initialize WebSocket.');\n      return;\n    }\n\n    // Initialize WebSocket connection\n    socket.current = new WebSocket(`ws://127.0.0.1:8080/ws/session/${sessionId}/`);\n    socket.current.onopen = () => {\n      console.log('WebSocket connection established');\n    };\n    socket.current.onmessage = event => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'audio') {\n        console.log('Audio data received:', data.payload);\n        playAudio(data.payload); // Play received audio\n      }\n    };\n    socket.current.onclose = () => {\n      console.warn('WebSocket disconnected.');\n    };\n    socket.current.onerror = error => {\n      console.error('WebSocket error:', error.message);\n    };\n  }, [sessionId, playAudio]); // Include playAudio in dependencies\n\n  useEffect(() => {\n    connectWebSocket();\n    return () => {\n      var _socket$current;\n      (_socket$current = socket.current) === null || _socket$current === void 0 ? void 0 : _socket$current.close();\n    };\n  }, [connectWebSocket]);\n\n  // Function to capture and send audio data\n  const startAudioCapture = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      }); // Corrected method name\n\n      // Attach the captured audio stream to the audioRef element\n      audioRef.current.srcObject = stream;\n      const audioContext = new AudioContext();\n\n      // Load the audio processor\n      await audioContext.audioWorklet.addModule('audio-processor.js');\n      const audioProcessor = new AudioWorkletNode(audioContext, 'audio-processor');\n      const input = audioContext.createMediaStreamSource(stream);\n      input.connect(audioProcessor);\n      audioProcessor.connect(audioContext.destination);\n\n      // Send audio data to the WebSocket\n      audioProcessor.port.onmessage = event => {\n        const audioChunk = event.data;\n        if (socket.current) {\n          socket.current.send(JSON.stringify({\n            type: 'audio',\n            payload: audioChunk\n          }));\n        }\n      };\n    } catch (error) {\n      console.error('Error capturing audio:', error.message);\n    }\n  };\n  const toggleMute = () => {\n    var _audioRef$current;\n    if ((_audioRef$current = audioRef.current) !== null && _audioRef$current !== void 0 && _audioRef$current.srcObject) {\n      const audioTracks = audioRef.current.srcObject.getAudioTracks();\n      audioTracks.forEach(track => track.enabled = !isMuted);\n      setIsMuted(!isMuted);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 160,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: toggleMute,\n      children: isMuted ? 'Unmute' : 'Mute'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startAudioCapture,\n      children: \"Start Audio\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 162,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 159,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioChat, \"PaS12QVakuWyYIQhGsymiK5hF9Y=\", false, function () {\n  return [useSession];\n});\n_c = AudioChat;\nexport default AudioChat;\nvar _c;\n$RefreshReg$(_c, \"AudioChat\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useState","useSession","jsxDEV","_jsxDEV","AudioChat","_s","sessionId","audioRef","socket","isMuted","setIsMuted","createWAV","pcmData","sampleRate","numChannels","wavHeader","Uint8Array","wavBody","Float32Array","dataSize","length","totalSize","dataView","DataView","buffer","setUint32","setUint16","Blob","Uint16Array","map","x","type","playAudio","floatArray","Object","values","wavBlob","audioContext","AudioContext","state","resume","reader","FileReader","onload","arrayBuffer","result","decodeAudioData","then","decodedData","source","createBufferSource","connect","destination","start","catch","error","console","readAsArrayBuffer","message","connectWebSocket","current","WebSocket","onopen","log","onmessage","event","data","JSON","parse","payload","onclose","warn","onerror","_socket$current","close","startAudioCapture","stream","navigator","mediaDevices","getUserMedia","audio","srcObject","audioWorklet","addModule","audioProcessor","AudioWorkletNode","input","createMediaStreamSource","port","audioChunk","send","stringify","toggleMute","_audioRef$current","audioTracks","getAudioTracks","forEach","track","enabled","children","ref","autoPlay","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["C:/Users/wesle/OneDrive/Documents/VLCS/myProject/VirtualLCS/frontend/src/AudioChat.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useState } from 'react';\r\nimport { useSession } from './SessionContext';\r\n\r\nconst AudioChat = () => {\r\n  const { sessionId } = useSession();\r\n  const audioRef = useRef(null);\r\n  const socket = useRef(null);\r\n  const [isMuted, setIsMuted] = useState(false);\r\n\r\n  // Utility to convert PCM data to WAV format\r\n  const createWAV = (pcmData) => {\r\n    const sampleRate = 44100; // Example sample rate\r\n    const numChannels = 1; // Mono audio\r\n\r\n    const wavHeader = new Uint8Array(44); // RIFF header size\r\n    const wavBody = new Float32Array(pcmData);\r\n\r\n    // Fill WAV header\r\n    const dataSize = wavBody.length * 2; // PCM data size (bytes)\r\n    const totalSize = dataSize + 44;\r\n\r\n    const dataView = new DataView(wavHeader.buffer);\r\n    dataView.setUint32(0, 0x52494646); // \"RIFF\"\r\n    dataView.setUint32(4, totalSize - 8, true); // File size - 8\r\n    dataView.setUint32(8, 0x57415645); // \"WAVE\"\r\n    dataView.setUint32(12, 0x666d7420); // \"fmt \"\r\n    dataView.setUint32(16, 16, true); // PCM chunk size\r\n    dataView.setUint16(20, 1, true); // Audio format (1=PCM)\r\n    dataView.setUint16(22, numChannels, true); // Number of channels\r\n    dataView.setUint32(24, sampleRate, true); // Sample rate\r\n    dataView.setUint32(28, sampleRate * numChannels * 2, true); // Byte rate\r\n    dataView.setUint16(32, numChannels * 2, true); // Block align\r\n    dataView.setUint16(34, 16, true); // Bits per sample\r\n    dataView.setUint32(36, 0x64617461); // \"data\"\r\n    dataView.setUint32(40, dataSize, true); // PCM data size\r\n\r\n    // Combine header and body\r\n    return new Blob([wavHeader, new Uint16Array(wavBody.map(x => x * 32767))], { type: 'audio/wav' });\r\n  };\r\n\r\n  // Wrap playAudio in useCallback\r\n  const playAudio = useCallback((pcmData) => {\r\n    try {\r\n      // Convert the received audio data object to a Float32Array\r\n      const floatArray = new Float32Array(Object.values(pcmData));\r\n\r\n      // Convert PCM to WAV format\r\n      const wavBlob = createWAV(floatArray);\r\n\r\n      const audioContext = new AudioContext();\r\n\r\n      // Ensure the AudioContext is running\r\n      if (audioContext.state === 'suspended') {\r\n        audioContext.resume();\r\n      }\r\n\r\n      const reader = new FileReader();\r\n      reader.onload = () => {\r\n        const arrayBuffer = reader.result;\r\n\r\n        // Decode and play the WAV data\r\n        audioContext.decodeAudioData(arrayBuffer).then((decodedData) => {\r\n          const source = audioContext.createBufferSource();\r\n          source.buffer = decodedData;\r\n          source.connect(audioContext.destination);\r\n          source.start();\r\n        }).catch((error) => {\r\n          console.error(\"Error decoding audio data:\", error);\r\n        });\r\n      };\r\n\r\n      reader.readAsArrayBuffer(wavBlob); // Read the WAV Blob as ArrayBuffer\r\n    } catch (error) {\r\n      console.error(\"Error playing audio:\", error.message);\r\n    }\r\n  }, []); // Add dependencies if needed\r\n\r\n  const connectWebSocket = useCallback(() => {\r\n    if (!sessionId) {\r\n      console.error('Session ID is undefined. Unable to initialize WebSocket.');\r\n      return;\r\n    }\r\n\r\n    // Initialize WebSocket connection\r\n    socket.current = new WebSocket(`ws://127.0.0.1:8080/ws/session/${sessionId}/`);\r\n\r\n    socket.current.onopen = () => {\r\n      console.log('WebSocket connection established');\r\n    };\r\n\r\n    socket.current.onmessage = (event) => {\r\n      const data = JSON.parse(event.data);\r\n\r\n      if (data.type === 'audio') {\r\n        console.log('Audio data received:', data.payload);\r\n        playAudio(data.payload); // Play received audio\r\n      }\r\n    };\r\n\r\n    socket.current.onclose = () => {\r\n      console.warn('WebSocket disconnected.');\r\n    };\r\n\r\n    socket.current.onerror = (error) => {\r\n      console.error('WebSocket error:', error.message);\r\n    };\r\n  }, [sessionId, playAudio]); // Include playAudio in dependencies\r\n\r\n  useEffect(() => {\r\n    connectWebSocket();\r\n\r\n    return () => {\r\n      socket.current?.close();\r\n    };\r\n  }, [connectWebSocket]);\r\n\r\n  // Function to capture and send audio data\r\n  const startAudioCapture = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); // Corrected method name\r\n  \r\n      // Attach the captured audio stream to the audioRef element\r\n      audioRef.current.srcObject = stream;\r\n  \r\n      const audioContext = new AudioContext();\r\n  \r\n      // Load the audio processor\r\n      await audioContext.audioWorklet.addModule('audio-processor.js');\r\n      const audioProcessor = new AudioWorkletNode(audioContext, 'audio-processor');\r\n  \r\n      const input = audioContext.createMediaStreamSource(stream);\r\n      input.connect(audioProcessor);\r\n      audioProcessor.connect(audioContext.destination);\r\n  \r\n      // Send audio data to the WebSocket\r\n      audioProcessor.port.onmessage = (event) => {\r\n        const audioChunk = event.data;\r\n        if (socket.current) {\r\n          socket.current.send(JSON.stringify({\r\n            type: 'audio',\r\n            payload: audioChunk,\r\n          }));\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.error('Error capturing audio:', error.message);\r\n    }\r\n  };\r\n\r\n  const toggleMute = () => {\r\n    if (audioRef.current?.srcObject) {\r\n      const audioTracks = audioRef.current.srcObject.getAudioTracks();\r\n      audioTracks.forEach((track) => (track.enabled = !isMuted));\r\n      setIsMuted(!isMuted);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <audio ref={audioRef} autoPlay />\r\n      <button onClick={toggleMute}>{isMuted ? 'Unmute' : 'Mute'}</button>\r\n      <button onClick={startAudioCapture}>Start Audio</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AudioChat;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}