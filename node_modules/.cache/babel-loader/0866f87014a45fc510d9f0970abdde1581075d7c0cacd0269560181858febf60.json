{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wesle\\\\OneDrive\\\\Documents\\\\VLCS\\\\myProject\\\\VirtualLCS\\\\frontend\\\\src\\\\AudioChat.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback, useState } from 'react';\nimport { useSession } from './SessionContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioChat = () => {\n  _s();\n  const {\n    sessionId\n  } = useSession();\n  const audioRef = useRef(null);\n  const socket = useRef(null);\n  const [isMuted, setIsMuted] = useState(false);\n\n  // Utility to convert PCM data to WAV format\n  const createWAV = pcmData => {\n    const sampleRate = 44100; // Example sample rate\n    const numChannels = 1; // Mono audio\n\n    const wavHeader = new Uint8Array(44); // RIFF header size\n    const wavBody = new Float32Array(pcmData);\n\n    // Fill WAV header\n    const dataSize = wavBody.length * 2; // PCM data size (bytes)\n    const totalSize = dataSize + 44;\n\n    // Writing RIFF chunk descriptor\n    const dataView = new DataView(wavHeader.buffer);\n    dataView.setUint32(0, 0x52494646); // \"RIFF\"\n    dataView.setUint32(4, totalSize - 8, true); // File size - 8\n    dataView.setUint32(8, 0x57415645); // \"WAVE\"\n\n    // Writing fmt sub-chunk\n    dataView.setUint32(12, 0x666d7420); // \"fmt \"\n    dataView.setUint32(16, 16, true); // PCM chunk size\n    dataView.setUint16(20, 1, true); // Audio format (1=PCM)\n    dataView.setUint16(22, numChannels, true); // Number of channels\n    dataView.setUint32(24, sampleRate, true); // Sample rate\n    dataView.setUint32(28, sampleRate * numChannels * 2, true); // Byte rate\n    dataView.setUint16(32, numChannels * 2, true); // Block align\n    dataView.setUint16(34, 16, true); // Bits per sample\n\n    // Writing data sub-chunk\n    dataView.setUint32(36, 0x64617461); // \"data\"\n    dataView.setUint32(40, dataSize, true); // PCM data size\n\n    // Combine header and body\n    return new Blob([wavHeader, new Uint16Array(wavBody.map(x => x * 32767))], {\n      type: 'audio/wav'\n    });\n  };\n  const playAudio = pcmData => {\n    try {\n      // Convert PCM to WAV format\n      const wavBlob = createWAV(pcmData);\n      const audioContext = new AudioContext();\n      const reader = new FileReader();\n      reader.onload = () => {\n        const arrayBuffer = reader.result;\n\n        // Decode and play the WAV data\n        audioContext.decodeAudioData(arrayBuffer).then(decodedData => {\n          const source = audioContext.createBufferSource();\n          source.buffer = decodedData;\n          source.connect(audioContext.destination);\n          source.start();\n        }).catch(error => {\n          console.error(\"Error decoding audio data:\", error);\n        });\n      };\n      reader.readAsArrayBuffer(wavBlob); // Read the WAV Blob as ArrayBuffer\n    } catch (error) {\n      console.error(\"Error playing audio:\", error.message);\n    }\n  };\n  const connectWebSocket = useCallback(() => {\n    if (!sessionId) {\n      console.error('Session ID is undefined. Unable to initialize WebSocket.');\n      return;\n    }\n\n    // Initialize WebSocket connection\n    socket.current = new WebSocket(`ws://127.0.0.1:8080/ws/session/${sessionId}/`);\n    socket.current.onopen = () => {\n      console.log('WebSocket connection established');\n    };\n    socket.current.onmessage = event => {\n      const data = JSON.parse(event.data);\n      if (data.type === 'audio') {\n        console.log('Audio data received:', data.payload);\n        playAudio(data.payload); // Play received audio\n      }\n    };\n    socket.current.onclose = () => {\n      console.warn('WebSocket disconnected.');\n    };\n    socket.current.onerror = error => {\n      console.error('WebSocket error:', error.message);\n    };\n  }, [sessionId, playAudio]);\n  useEffect(() => {\n    connectWebSocket();\n    return () => {\n      var _socket$current;\n      (_socket$current = socket.current) === null || _socket$current === void 0 ? void 0 : _socket$current.close();\n    };\n  }, [connectWebSocket]);\n\n  // Function to capture and send audio data\n  const startAudioCapture = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n\n      // Attach the captured audio stream to the audioRef element\n      audioRef.current.srcObject = stream;\n      const audioContext = new AudioContext();\n\n      // Load the audio processor\n      await audioContext.audioWorklet.addModule('audio-processor.js');\n      const audioProcessor = new AudioWorkletNode(audioContext, 'audio-processor');\n      const input = audioContext.createMediaStreamSource(stream);\n      input.connect(audioProcessor);\n      audioProcessor.connect(audioContext.destination);\n\n      // Send audio data to the WebSocket\n      audioProcessor.port.onmessage = event => {\n        const audioChunk = event.data;\n        if (socket.current) {\n          socket.current.send(JSON.stringify({\n            type: 'audio',\n            payload: audioChunk\n          }));\n        }\n      };\n    } catch (error) {\n      console.error('Error capturing audio:', error.message);\n    }\n  };\n\n  // Function to play incoming audio\n\n  const toggleMute = () => {\n    var _audioRef$current;\n    if ((_audioRef$current = audioRef.current) !== null && _audioRef$current !== void 0 && _audioRef$current.srcObject) {\n      const audioTracks = audioRef.current.srcObject.getAudioTracks();\n      audioTracks.forEach(track => track.enabled = !isMuted);\n      setIsMuted(!isMuted);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: audioRef,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: toggleMute,\n      children: isMuted ? 'Unmute' : 'Mute'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 160,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startAudioCapture,\n      children: \"Start Audio\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 158,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioChat, \"XzpHZhh3M/v7Rykrcin+2gjorCw=\", false, function () {\n  return [useSession];\n});\n_c = AudioChat;\nexport default AudioChat;\nvar _c;\n$RefreshReg$(_c, \"AudioChat\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useState","useSession","jsxDEV","_jsxDEV","AudioChat","_s","sessionId","audioRef","socket","isMuted","setIsMuted","createWAV","pcmData","sampleRate","numChannels","wavHeader","Uint8Array","wavBody","Float32Array","dataSize","length","totalSize","dataView","DataView","buffer","setUint32","setUint16","Blob","Uint16Array","map","x","type","playAudio","wavBlob","audioContext","AudioContext","reader","FileReader","onload","arrayBuffer","result","decodeAudioData","then","decodedData","source","createBufferSource","connect","destination","start","catch","error","console","readAsArrayBuffer","message","connectWebSocket","current","WebSocket","onopen","log","onmessage","event","data","JSON","parse","payload","onclose","warn","onerror","_socket$current","close","startAudioCapture","stream","navigator","mediaDevices","getUserMedia","audio","srcObject","audioWorklet","addModule","audioProcessor","AudioWorkletNode","input","createMediaStreamSource","port","audioChunk","send","stringify","toggleMute","_audioRef$current","audioTracks","getAudioTracks","forEach","track","enabled","children","ref","autoPlay","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["C:/Users/wesle/OneDrive/Documents/VLCS/myProject/VirtualLCS/frontend/src/AudioChat.jsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback, useState } from 'react';\r\nimport { useSession } from './SessionContext';\r\n\r\nconst AudioChat = () => {\r\n  const { sessionId } = useSession();\r\n  const audioRef = useRef(null);\r\n  const socket = useRef(null);\r\n  const [isMuted, setIsMuted] = useState(false);\r\n\r\n  // Utility to convert PCM data to WAV format\r\n  const createWAV = (pcmData) => {\r\n    const sampleRate = 44100; // Example sample rate\r\n    const numChannels = 1; // Mono audio\r\n\r\n    const wavHeader = new Uint8Array(44); // RIFF header size\r\n    const wavBody = new Float32Array(pcmData);\r\n\r\n    // Fill WAV header\r\n    const dataSize = wavBody.length * 2; // PCM data size (bytes)\r\n    const totalSize = dataSize + 44;\r\n\r\n    // Writing RIFF chunk descriptor\r\n    const dataView = new DataView(wavHeader.buffer);\r\n    dataView.setUint32(0, 0x52494646); // \"RIFF\"\r\n    dataView.setUint32(4, totalSize - 8, true); // File size - 8\r\n    dataView.setUint32(8, 0x57415645); // \"WAVE\"\r\n\r\n    // Writing fmt sub-chunk\r\n    dataView.setUint32(12, 0x666d7420); // \"fmt \"\r\n    dataView.setUint32(16, 16, true); // PCM chunk size\r\n    dataView.setUint16(20, 1, true); // Audio format (1=PCM)\r\n    dataView.setUint16(22, numChannels, true); // Number of channels\r\n    dataView.setUint32(24, sampleRate, true); // Sample rate\r\n    dataView.setUint32(28, sampleRate * numChannels * 2, true); // Byte rate\r\n    dataView.setUint16(32, numChannels * 2, true); // Block align\r\n    dataView.setUint16(34, 16, true); // Bits per sample\r\n\r\n    // Writing data sub-chunk\r\n    dataView.setUint32(36, 0x64617461); // \"data\"\r\n    dataView.setUint32(40, dataSize, true); // PCM data size\r\n\r\n    // Combine header and body\r\n    return new Blob([wavHeader, new Uint16Array(wavBody.map(x => x * 32767))], { type: 'audio/wav' });\r\n  };\r\n  const playAudio = (pcmData) => {\r\n    try {\r\n      // Convert PCM to WAV format\r\n      const wavBlob = createWAV(pcmData); \r\n  \r\n      const audioContext = new AudioContext();\r\n      const reader = new FileReader();\r\n  \r\n      reader.onload = () => {\r\n        const arrayBuffer = reader.result;\r\n  \r\n        // Decode and play the WAV data\r\n        audioContext.decodeAudioData(arrayBuffer).then((decodedData) => {\r\n          const source = audioContext.createBufferSource();\r\n          source.buffer = decodedData;\r\n          source.connect(audioContext.destination);\r\n          source.start();\r\n        }).catch((error) => {\r\n          console.error(\"Error decoding audio data:\", error);\r\n        });\r\n      };\r\n  \r\n      reader.readAsArrayBuffer(wavBlob); // Read the WAV Blob as ArrayBuffer\r\n    } catch (error) {\r\n      console.error(\"Error playing audio:\", error.message);\r\n    }\r\n  };\r\n\r\n  const connectWebSocket = useCallback(() => {\r\n    if (!sessionId) {\r\n      console.error('Session ID is undefined. Unable to initialize WebSocket.');\r\n      return;\r\n    }\r\n\r\n    // Initialize WebSocket connection\r\n    socket.current = new WebSocket(`ws://127.0.0.1:8080/ws/session/${sessionId}/`);\r\n\r\n    socket.current.onopen = () => {\r\n      console.log('WebSocket connection established');\r\n    };\r\n\r\n    socket.current.onmessage = (event) => {\r\n      const data = JSON.parse(event.data);\r\n\r\n      if (data.type === 'audio') {\r\n        console.log('Audio data received:', data.payload);\r\n        playAudio(data.payload); // Play received audio\r\n      }\r\n    };\r\n\r\n    socket.current.onclose = () => {\r\n      console.warn('WebSocket disconnected.');\r\n    };\r\n\r\n    socket.current.onerror = (error) => {\r\n      console.error('WebSocket error:', error.message);\r\n    };\r\n  }, [sessionId, playAudio]);\r\n\r\n  useEffect(() => {\r\n    connectWebSocket();\r\n\r\n    return () => {\r\n      socket.current?.close();\r\n    };\r\n  }, [connectWebSocket]);\r\n\r\n  // Function to capture and send audio data\r\n  const startAudioCapture = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n\r\n      // Attach the captured audio stream to the audioRef element\r\n      audioRef.current.srcObject = stream;\r\n\r\n      const audioContext = new AudioContext();\r\n\r\n      // Load the audio processor\r\n      await audioContext.audioWorklet.addModule('audio-processor.js');\r\n      const audioProcessor = new AudioWorkletNode(audioContext, 'audio-processor');\r\n\r\n      const input = audioContext.createMediaStreamSource(stream);\r\n      input.connect(audioProcessor);\r\n      audioProcessor.connect(audioContext.destination);\r\n\r\n      // Send audio data to the WebSocket\r\n      audioProcessor.port.onmessage = (event) => {\r\n        const audioChunk = event.data;\r\n        if (socket.current) {\r\n          socket.current.send(JSON.stringify({\r\n            type: 'audio',\r\n            payload: audioChunk,\r\n          }));\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.error('Error capturing audio:', error.message);\r\n    }\r\n  };\r\n\r\n  // Function to play incoming audio\r\n  \r\n  \r\n\r\n  const toggleMute = () => {\r\n    if (audioRef.current?.srcObject) {\r\n      const audioTracks = audioRef.current.srcObject.getAudioTracks();\r\n      audioTracks.forEach((track) => (track.enabled = !isMuted));\r\n      setIsMuted(!isMuted);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <audio ref={audioRef} autoPlay />\r\n      <button onClick={toggleMute}>{isMuted ? 'Unmute' : 'Mute'}</button>\r\n      <button onClick={startAudioCapture}>Start Audio</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AudioChat;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}